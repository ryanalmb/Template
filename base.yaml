AWSTemplateFormatVersion: '2010-09-09'
Description: 'Enterprise Sports Analytics Telegram Bot with Multi-modal AI'

Parameters:
  TelegramBotToken:
    Type: String
    NoEcho: true
    Description: Telegram Bot Token
  SportsAPIKey:
    Type: String
    NoEcho: true
    Description: Sports Data API Key
  Environment:
    Type: String
    Default: prod
    AllowedValues: [dev, prod]

Resources:
  # DynamoDB Tables
  GamesTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "${AWS::StackName}-games"
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: gameId
          AttributeType: S
        - AttributeName: sport
          AttributeType: S
      KeySchema:
        - AttributeName: gameId
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: sport-index
          KeySchema:
            - AttributeName: sport
              KeyType: HASH
          Projection:
            ProjectionType: ALL
      StreamSpecification:
        StreamViewType: NEW_AND_OLD_IMAGES

  PredictionsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "${AWS::StackName}-predictions"
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: predictionId
          AttributeType: S
        - AttributeName: gameId
          AttributeType: S
      KeySchema:
        - AttributeName: predictionId
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: gameId-index
          KeySchema:
            - AttributeName: gameId
              KeyType: HASH
          Projection:
            ProjectionType: ALL

  # S3 Buckets
  MediaBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "${AWS::StackName}-media-${AWS::AccountId}"
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256

  # Secrets Manager
  BotSecrets:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub "${AWS::StackName}/bot-config"
      SecretString: !Sub |
        {
          "telegram_token": "${TelegramBotToken}",
          "sports_api_key": "${SportsAPIKey}"
        }

  # IAM Role for Lambda
  LambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: BotPermissions
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:*
                Resource:
                  - !GetAtt GamesTable.Arn
                  - !GetAtt PredictionsTable.Arn
                  - !Sub "${GamesTable.Arn}/index/*"
                  - !Sub "${PredictionsTable.Arn}/index/*"
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                Resource: "*"
              - Effect: Allow
                Action:
                  - rekognition:*
                  - textract:*
                  - comprehend:*
                Resource: "*"
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                Resource: !Sub "${MediaBucket}/*"
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource: !Ref BotSecrets

  # Main Lambda Function
  TelegramBotFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-bot"
      Runtime: python3.11
      Handler: index.lambda_handler
      Timeout: 300
      MemorySize: 1024
      Role: !GetAtt LambdaRole.Arn
      Environment:
        Variables:
          GAMES_TABLE: !Ref GamesTable
          PREDICTIONS_TABLE: !Ref PredictionsTable
          MEDIA_BUCKET: !Ref MediaBucket
          SECRET_ARN: !Ref BotSecrets
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import requests
          from datetime import datetime
          import uuid
          import base64
          
          # AWS clients
          dynamodb = boto3.resource('dynamodb')
          bedrock = boto3.client('bedrock-runtime')
          rekognition = boto3.client('rekognition')
          textract = boto3.client('textract')
          comprehend = boto3.client('comprehend')
          s3 = boto3.client('s3')
          secrets = boto3.client('secretsmanager')
          
          # Tables
          games_table = dynamodb.Table(os.environ['GAMES_TABLE'])
          predictions_table = dynamodb.Table(os.environ['PREDICTIONS_TABLE'])
          
          def get_secrets():
              response = secrets.get_secret_value(SecretId=os.environ['SECRET_ARN'])
              return json.loads(response['SecretString'])
          
          def send_message(chat_id, text, keyboard=None):
              secrets_data = get_secrets()
              url = f"https://api.telegram.org/bot{secrets_data['telegram_token']}/sendMessage"
              payload = {'chat_id': chat_id, 'text': text, 'parse_mode': 'HTML'}
              if keyboard:
                  payload['reply_markup'] = json.dumps(keyboard)
              return requests.post(url, json=payload)
          
          def analyze_with_bedrock(prompt):
              try:
                  body = json.dumps({
                      "anthropic_version": "bedrock-2023-05-31",
                      "max_tokens": 2000,
                      "messages": [{"role": "user", "content": prompt}]
                  })
                  
                  response = bedrock.invoke_model(
                      body=body,
                      modelId='anthropic.claude-3-haiku-20240307-v1:0',
                      accept='application/json',
                      contentType='application/json'
                  )
                  
                  result = json.loads(response.get('body').read())
                  return result['content'][0]['text']
              except Exception as e:
                  return f"Analysis error: {str(e)}"
          
          def analyze_image(image_bytes):
              try:
                  # Rekognition for labels
                  labels = rekognition.detect_labels(
                      Image={'Bytes': image_bytes},
                      MaxLabels=10
                  )['Labels']
                  
                  # Textract for text
                  text_response = textract.detect_document_text(
                      Document={'Bytes': image_bytes}
                  )
                  
                  extracted_text = ""
                  for block in text_response['Blocks']:
                      if block['BlockType'] == 'LINE':
                          extracted_text += block['Text'] + " "
                  
                  return {
                      'labels': [l['Name'] for l in labels],
                      'text': extracted_text.strip()
                  }
              except Exception as e:
                  return {'error': str(e)}
          
          def get_sports_data(sport='nfl'):
              try:
                  # ESPN API endpoint
                  url = f"https://site.api.espn.com/apis/site/v2/sports/football/{sport}/scoreboard"
                  response = requests.get(url, timeout=10)
                  data = response.json()
                  
                  games = []
                  for event in data.get('events', [])[:5]:
                      game = {
                          'id': event['id'],
                          'date': event['date'],
                          'teams': [comp['team']['displayName'] 
                                   for comp in event['competitions'][0]['competitors']]
                      }
                      games.append(game)
                  return games
              except:
                  return []
          
          def handle_start(chat_id):
              text = """üèÜ <b>Sports Analytics Pro</b>
          
          AI-powered sports analysis with:
          üìä Real-time predictions
          üì∏ Image analysis
          üéØ Multi-sport coverage
          
          <b>Commands:</b>
          /games [sport] - Upcoming games
          /analyze [team1] vs [team2] - Game analysis
          /predict [game_id] - AI prediction
          
          Send photos for instant analysis!"""
              
              keyboard = {
                  'inline_keyboard': [
                      [{'text': 'üèà NFL', 'callback_data': 'nfl'},
                       {'text': 'üèÄ NBA', 'callback_data': 'nba'}],
                      [{'text': '‚öæ MLB', 'callback_data': 'mlb'},
                       {'text': 'üèí NHL', 'callback_data': 'nhl'}]
                  ]
              }
              send_message(chat_id, text, keyboard)
          
          def lambda_handler(event, context):
              try:
                  body = json.loads(event.get('body', '{}'))
                  
                  if 'message' in body:
                      message = body['message']
                      chat_id = str(message['chat']['id'])
                      
                      if 'text' in message:
                          text = message['text']
                          
                          if text.startswith('/start'):
                              handle_start(chat_id)
                          
                          elif text.startswith('/games'):
                              sport = text.split()[1] if len(text.split()) > 1 else 'nfl'
                              games = get_sports_data(sport)
                              
                              if games:
                                  games_text = f"üèÜ <b>{sport.upper()} Games:</b>\n\n"
                                  for game in games:
                                      teams = " vs ".join(game['teams'])
                                      games_text += f"üèüÔ∏è {teams}\nüìÖ {game['date'][:10]}\n\n"
                                  send_message(chat_id, games_text)
                              else:
                                  send_message(chat_id, "No games found.")
                          
                          elif text.startswith('/analyze'):
                              query = text.replace('/analyze', '').strip()
                              if ' vs ' in query.lower():
                                  send_message(chat_id, "ü§ñ Analyzing...")
                                  
                                  prompt = f"""Analyze this matchup: {query}
                                  Provide:
                                  1. Win probability for each team
                                  2. Key factors
                                  3. Score prediction
                                  Keep response under 500 words."""
                                  
                                  analysis = analyze_with_bedrock(prompt)
                                  send_message(chat_id, f"üéØ <b>Analysis:</b>\n{analysis}")
                              else:
                                  send_message(chat_id, "Use: /analyze Team1 vs Team2")
                          
                          else:
                              send_message(chat_id, "Unknown command. Try /start")
                      
                      elif 'photo' in message:
                          send_message(chat_id, "üì∏ Analyzing image...")
                          # In real implementation, download and process the photo
                          send_message(chat_id, "üîç Sports content detected!")
                  
                  elif 'callback_query' in body:
                      callback = body['callback_query']
                      chat_id = str(callback['message']['chat']['id'])
                      sport = callback['data']
                      
                      games = get_sports_data(sport)
                      if games:
                          text = f"üèÜ <b>{sport.upper()} Games:</b>\n\n"
                          for game in games:
                              teams = " vs ".join(game['teams'])
                              text += f"üèüÔ∏è {teams}\n"
                      else:
                          text = f"No {sport.upper()} games found."
                      
                      send_message(chat_id, text)
                  
                  return {'statusCode': 200}
              
              except Exception as e:
                  print(f"Error: {str(e)}")
                  return {'statusCode': 500}

  # API Gateway for webhook
  ApiGateway:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub "${AWS::StackName}-api"
      Description: Telegram Bot Webhook API

  ApiGatewayResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: webhook

  ApiGatewayMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResource
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TelegramBotFunction.Arn}/invocations"

  ApiGatewayDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn: ApiGatewayMethod
    Properties:
      RestApiId: !Ref ApiGateway
      StageName: !Ref Environment

  LambdaApiGatewayPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref TelegramBotFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "${ApiGateway}/*/POST/webhook"

  # SageMaker Notebook for model development
  SageMakerRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: sagemaker.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSageMakerFullAccess

  NotebookInstance:
    Type: AWS::SageMaker::NotebookInstance
    Properties:
      NotebookInstanceName: !Sub "${AWS::StackName}-notebook"
      InstanceType: ml.t3.medium
      RoleArn: !GetAtt SageMakerRole.Arn

  # EventBridge for scheduled analysis
  ScheduleRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: events.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: InvokeLambda
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: lambda:InvokeFunction
                Resource: !GetAtt TelegramBotFunction.Arn

  DailyAnalysisSchedule:
    Type: AWS::Events::Rule
    Properties:
      Description: Daily sports analysis trigger
      ScheduleExpression: "cron(0 12 * * ? *)"
      State: ENABLED
      Targets:
        - Arn: !GetAtt TelegramBotFunction.Arn
          Id: DailyTrigger
          Input: '{"scheduled": true, "type": "daily_analysis"}'

  ScheduleLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref TelegramBotFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt DailyAnalysisSchedule.Arn

Outputs:
  WebhookURL:
    Description: Telegram Bot Webhook URL
    Value: !Sub "https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/${Environment}/webhook"
  
  BotFunctionArn:
    Description: Lambda Function ARN
    Value: !GetAtt TelegramBotFunction.Arn
  
  NotebookURL:
    Description: SageMaker Notebook URL
    Value: !Sub "https://${AWS::Region}.console.aws.amazon.com/sagemaker/home?region=${AWS::Region}#/notebook-instances/${NotebookInstance}"

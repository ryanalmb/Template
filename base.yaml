# Updated IAM Role with explicit permissions and dependencies
LambdaRole:
  Type: AWS::IAM::Role
  Properties:
    RoleName: !Sub "${AWS::StackName}-lambda-role"
    AssumeRolePolicyDocument:
      Version: '2012-10-17'
      Statement:
        - Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action: sts:AssumeRole
    ManagedPolicyArns:
      - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
    Policies:
      - PolicyName: BotPermissions
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
            - Effect: Allow
              Action:
                - dynamodb:Query
                - dynamodb:Scan
                - dynamodb:GetItem
                - dynamodb:PutItem
                - dynamodb:UpdateItem
                - dynamodb:DeleteItem
              Resource:
                - !GetAtt GamesTable.Arn
                - !GetAtt PredictionsTable.Arn
                - !Sub "${GamesTable.Arn}/index/*"
                - !Sub "${PredictionsTable.Arn}/index/*"
            - Effect: Allow
              Action:
                - bedrock:InvokeModel
                - bedrock:InvokeModelWithResponseStream
              Resource: 
                - !Sub "arn:aws:bedrock:${AWS::Region}::foundation-model/anthropic.claude-3-haiku-20240307-v1:0"
            - Effect: Allow
              Action:
                - rekognition:DetectLabels
                - rekognition:DetectText
                - rekognition:DetectFaces
              Resource: "*"
            - Effect: Allow
              Action:
                - textract:DetectDocumentText
                - textract:AnalyzeDocument
              Resource: "*"
            - Effect: Allow
              Action:
                - comprehend:DetectSentiment
                - comprehend:DetectEntities
              Resource: "*"
            - Effect: Allow
              Action:
                - s3:GetObject
                - s3:PutObject
              Resource: !Sub "${MediaBucket}/*"
            - Effect: Allow
              Action:
                - secretsmanager:GetSecretValue
              Resource: !Ref BotSecrets
            - Effect: Allow
              Action:
                - logs:CreateLogGroup
                - logs:CreateLogStream
                - logs:PutLogEvents
              Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*"

# Updated Lambda Function with explicit dependencies
TelegramBotFunction:
  Type: AWS::Lambda::Function
  DependsOn: 
    - LambdaRole
    - GamesTable
    - PredictionsTable
    - MediaBucket
    - BotSecrets
  Properties:
    FunctionName: !Sub "${AWS::StackName}-bot"
    Runtime: python3.11
    Handler: index.lambda_handler
    Timeout: 300
    MemorySize: 1024
    Role: !GetAtt LambdaRole.Arn
    Environment:
      Variables:
        GAMES_TABLE: !Ref GamesTable
        PREDICTIONS_TABLE: !Ref PredictionsTable
        MEDIA_BUCKET: !Ref MediaBucket
        SECRET_ARN: !Ref BotSecrets
        AWS_REGION: !Ref AWS::Region
    Code:
      ZipFile: |
        import json
        import boto3
        import os
        import requests
        from datetime import datetime
        import uuid
        import base64
        
        # AWS clients
        try:
            dynamodb = boto3.resource('dynamodb')
            bedrock = boto3.client('bedrock-runtime')
            rekognition = boto3.client('rekognition')
            textract = boto3.client('textract')
            comprehend = boto3.client('comprehend')
            s3 = boto3.client('s3')
            secrets = boto3.client('secretsmanager')
            
            # Tables
            games_table = dynamodb.Table(os.environ['GAMES_TABLE'])
            predictions_table = dynamodb.Table(os.environ['PREDICTIONS_TABLE'])
        except Exception as e:
            print(f"Initialization error: {str(e)}")
        
        def get_secrets():
            try:
                response = secrets.get_secret_value(SecretId=os.environ['SECRET_ARN'])
                return json.loads(response['SecretString'])
            except Exception as e:
                print(f"Secret retrieval error: {str(e)}")
                return {}
        
        def send_message(chat_id, text, keyboard=None):
            try:
                secrets_data = get_secrets()
                if not secrets_data.get('telegram_token'):
                    return {'error': 'No telegram token'}
                    
                url = f"https://api.telegram.org/bot{secrets_data['telegram_token']}/sendMessage"
                payload = {'chat_id': chat_id, 'text': text, 'parse_mode': 'HTML'}
                if keyboard:
                    payload['reply_markup'] = json.dumps(keyboard)
                return requests.post(url, json=payload, timeout=10)
            except Exception as e:
                print(f"Send message error: {str(e)}")
                return {'error': str(e)}
        
        def analyze_with_bedrock(prompt):
            try:
                body = json.dumps({
                    "anthropic_version": "bedrock-2023-05-31",
                    "max_tokens": 2000,
                    "messages": [{"role": "user", "content": prompt}]
                })
                
                response = bedrock.invoke_model(
                    body=body,
                    modelId='anthropic.claude-3-haiku-20240307-v1:0',
                    accept='application/json',
                    contentType='application/json'
                )
                
                result = json.loads(response.get('body').read())
                return result['content'][0]['text']
            except Exception as e:
                return f"Analysis error: {str(e)}"
        
        def analyze_image(image_bytes):
            try:
                # Rekognition for labels
                labels = rekognition.detect_labels(
                    Image={'Bytes': image_bytes},
                    MaxLabels=10
                )['Labels']
                
                # Textract for text
                text_response = textract.detect_document_text(
                    Document={'Bytes': image_bytes}
                )
                
                extracted_text = ""
                for block in text_response['Blocks']:
                    if block['BlockType'] == 'LINE':
                        extracted_text += block['Text'] + " "
                
                return {
                    'labels': [l['Name'] for l in labels],
                    'text': extracted_text.strip()
                }
            except Exception as e:
                return {'error': str(e)}
        
        def get_sports_data(sport='nfl'):
            try:
                # ESPN API endpoint
                url = f"https://site.api.espn.com/apis/site/v2/sports/football/{sport}/scoreboard"
                response = requests.get(url, timeout=10)
                data = response.json()
                
                games = []
                for event in data.get('events', [])[:5]:
                    game = {
                        'id': event['id'],
                        'date': event['date'],
                        'teams': [comp['team']['displayName'] 
                                 for comp in event['competitions'][0]['competitors']]
                    }
                    games.append(game)
                return games
            except Exception as e:
                print(f"Sports data error: {str(e)}")
                return []
        
        def handle_start(chat_id):
            text = """üèÜ <b>Sports Analytics Pro</b>
        
        AI-powered sports analysis with:
        üìä Real-time predictions
        üì∏ Image analysis
        üéØ Multi-sport coverage
        
        <b>Commands:</b>
        /games [sport] - Upcoming games
        /analyze [team1] vs [team2] - Game analysis
        /predict [game_id] - AI prediction
        
        Send photos for instant analysis!"""
            
            keyboard = {
                'inline_keyboard': [
                    [{'text': 'üèà NFL', 'callback_data': 'nfl'},
                     {'text': 'üèÄ NBA', 'callback_data': 'nba'}],
                    [{'text': '‚öæ MLB', 'callback_data': 'mlb'},
                     {'text': 'üèí NHL', 'callback_data': 'nhl'}]
                ]
            }
            send_message(chat_id, text, keyboard)
        
        def lambda_handler(event, context):
            try:
                print(f"Received event: {json.dumps(event)}")
                
                body = json.loads(event.get('body', '{}'))
                
                if 'message' in body:
                    message = body['message']
                    chat_id = str(message['chat']['id'])
                    
                    if 'text' in message:
                        text = message['text']
                        
                        if text.startswith('/start'):
                            handle_start(chat_id)
                        
                        elif text.startswith('/games'):
                            sport = text.split()[1] if len(text.split()) > 1 else 'nfl'
                            games = get_sports_data(sport)
                            
                            if games:
                                games_text = f"üèÜ <b>{sport.upper()} Games:</b>\n\n"
                                for game in games:
                                    teams = " vs ".join(game['teams'])
                                    games_text += f"üèüÔ∏è {teams}\nüìÖ {game['date'][:10]}\n\n"
                                send_message(chat_id, games_text)
                            else:
                                send_message(chat_id, "No games found.")
                        
                        elif text.startswith('/analyze'):
                            query = text.replace('/analyze', '').strip()
                            if ' vs ' in query.lower():
                                send_message(chat_id, "ü§ñ Analyzing...")
                                
                                prompt = f"""Analyze this matchup: {query}
                                Provide:
                                1. Win probability for each team
                                2. Key factors
                                3. Score prediction
                                Keep response under 500 words."""
                                
                                analysis = analyze_with_bedrock(prompt)
                                send_message(chat_id, f"üéØ <b>Analysis:</b>\n{analysis}")
                            else:
                                send_message(chat_id, "Use: /analyze Team1 vs Team2")
                        
                        else:
                            send_message(chat_id, "Unknown command. Try /start")
                    
                    elif 'photo' in message:
                        send_message(chat_id, "üì∏ Analyzing image...")
                        # In real implementation, download and process the photo
                        send_message(chat_id, "üîç Sports content detected!")
                
                elif 'callback_query' in body:
                    callback = body['callback_query']
                    chat_id = str(callback['message']['chat']['id'])
                    sport = callback['data']
                    
                    games = get_sports_data(sport)
                    if games:
                        text = f"üèÜ <b>{sport.upper()} Games:</b>\n\n"
                        for game in games:
                            teams = " vs ".join(game['teams'])
                            text += f"üèüÔ∏è {teams}\n"
                    else:
                        text = f"No {sport.upper()} games found."
                    
                    send_message(chat_id, text)
                
                return {'statusCode': 200}
            
            except Exception as e:
                print(f"Error: {str(e)}")
                return {
                    'statusCode': 500,
                    'body': json.dumps({'error': str(e)})
                }
